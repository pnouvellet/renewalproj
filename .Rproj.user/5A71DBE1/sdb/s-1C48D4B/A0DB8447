{
    "collab_server" : "",
    "contents" : "#' Estimate of R's (and initial states) by MCMC sampling\n#'\n#'  gh\n#'\n#' @author Pierre Nouvellet (\\email{p.nouvellet@imperial.ac.uk})\n#'\n#' @export\n#'\n#' @param rep (a matrix of integer) daily time-series at the different location\n#' This can be any positive number.\n#'\n#' @param I (a single integer) number of of independent location.\n#'\n#' @param Mean_SI (a single real positive) mean of the serial interval.\n#'\n#' @param CV_SI (a single real positive) coefficient of variation of the serial interval.\n#'\n#' @param SI_trunc (a single real positive) threshold/cut-off for the serial interval calculation  \n#'\n#' @param sigma_Prop: (a vector of real positive(s) of size 2 x N), from 1:N values of the reproduction number,\n#' and from (N+1):(2N) values of the back calculated incdence at time T_prior- first date of time window\n#'\n#' @param T_prior (a single real positive) number of backward step for which incidence is backcalculated.\n#'\n#' @return\n#'  The function returns sum_{s=(t-SI_trunc)}^{t}(I_{t-s}w_s) for each day with the time window of interest.\n#'\n#'\n#' @examples\n#'\n#' \n#'\nR_estim_MCMC<-function(rep,I,Mean_SI,CV_SI,SI_trunc,sigma_Prop,T_prior)\n{\n  \n  N_sim <- nrow(I)\n  SI_Distr <- vector()\n  for(i in 0:SI_trunc) SI_Distr[i+1] <- DiscrSI(i, Mean_SI, CV_SI*Mean_SI)\n  SI_Distr<-SI_Distr/sum(SI_Distr)\n  # plot(0:SI_trunc,SI_Distr)\n  ws <- rev(SI_Distr) # reversed to use as past infectivity\n  \n  ###########################################################\n  ###########################################################\n  # Estimation of R0 based on renewal equation with MCMC sampling\n  ##################################################\n  ############################################################\n  \n  # useful parameters and results\n  \n  Acc <- matrix(NA,N_sim,2)        # will contain the acceptance rate for MCMC\n  thetas <- matrix(NA,rep,N_sim*2)  # parameters posterior, Rt+I0\n  L <- thetas                      # likelihoods\n\n  #############################################################################\n  #############################################################################\n  # initiallisation\n  init<-function(mu){\n    I0=matrix(0,1,SI_trunc+50)\n    I0[,1]=mu\n    for (i in 2:ncol(I0)){\n      f=max(c(1,(i-SI_trunc)))\n      I0[,i]=(I0[,f:i]%*%ws[((SI_trunc+1)-(i-f)):(SI_trunc+1)])\n    }\n    return(I0[1,ncol(I0)])\n  }\n  I0 <- rep(NA,N_sim)\n  for (i in 1:N_sim){\n    par_opt<-optim(7,function(x) (init(x)-mean(I[i,]))^2,method=\"Brent\",lower=0,upper=1e5)\n    I0[i]<-par_opt$par\n  }\n\n  \n  theta0 <- c(rep(1,N_sim),I0)#rep(1,N.country),rep(30,N.country))\n  lambda <- foi_renewal(I=I,N=N_sim,Theta=theta0,rSI=ws,T_prior=T_prior) \n  L1 <- Likelihood_renewal(lambda,I,theta0[1:N_sim])\n  L[1,] <- L1\n  thetas[1,] <- theta0       \n  #############################################################################\n  # sampling\n  for (i in 2:rep){   \n    print(i)\n    #print(i)\n    for (j in 1:(2*N_sim)){\n      Ts <- theta0\n      lambdaT <- lambda\n      Ts[j] <- Ts[j]*exp(sigma_Prop[j]*rnorm(1,0,1))\n      lambdaT <- foi_renewal(I=I,N=N_sim,Theta=Ts,rSI=ws,T_prior=1e2)\n      Lint <- Likelihood_renewal(lambdaT,I,Ts[1:N_sim])\n      if (j<3){\n        r <- exp(Lint-L1)*Ts[j]/theta0[j]\n      }else{\n        Lint <- Likelihood_renewal(lambdaT,I,Ts[1:N_sim])\n        r <- exp(Lint-L1)*Ts[j]/theta0[j]*exp(-Ts[j]/I0[j-N_sim])\n      }\n      if (runif(1,0,1)<= r){\n        theta0[j] <- Ts[j]\n        lambda <- lambdaT\n        L1 <- Lint\n      }  \n      L[i,j] <- L1    \n    }\n    thetas[i,] <- theta0\n  }\n  Acc <- colSums(diff(thetas)!=0)/rep  \n  \n  res <- list(post_theta = thetas, post_logLik = L, Acc_rate = Acc, SI_Distr=S1$SI_Distr)\n  \n  return(res)\n}",
    "created" : 1494944774218.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2658777829",
    "id" : "A0DB8447",
    "lastKnownWriteTime" : 1494945121,
    "last_content_update" : 1494945121836,
    "path" : "~/R_packages/renewalproj/R/R_estim_MCMC.R",
    "project_path" : "R/R_estim_MCMC.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}